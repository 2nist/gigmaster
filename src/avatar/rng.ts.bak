/**
 * Seeded Random Number Generator
 * 
 * Provides deterministic randomness for procedural avatar generation.
 * Uses Mulberry32 algorithm for fast, high-quality pseudo-random numbers.
 */

/**
 * Mulberry32 PRNG - Fast, high-quality seeded random number generator
 * @param seed - Numeric seed value
 * @returns Function that returns next random number [0, 1)
 */
export function mulberry32(seed: number): () => number {
  let state = seed;
  
  return function() {
    let t = state += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

/**
 * Create seeded RNG from string seed
 * @param seed - String seed (will be hashed to number)
 * @returns Function that returns next random number [0, 1)
 */
export function seededRNG(seed: string | number): () => number {
  const numericSeed = typeof seed === 'number' 
    ? seed 
    : hashString(seed);
  
  return mulberry32(numericSeed);
}

/**
 * Hash string to number
 * @param str - String to hash
 * @returns Numeric hash
 */
function hashString(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash) || 1;
}

/**
 * Generate jitter value for subtle randomness
 * @param rng - Random number generator function
 * @param range - Maximum jitter range
 * @returns Jitter value in range [-range/2, range/2]
 */
export function jitter(rng: () => number, range: number): number {
  return (rng() - 0.5) * range;
}

/**
 * Pick random item from array
 * @param rng - Random number generator function
 * @param items - Array of items to pick from
 * @returns Randomly selected item
 */
export function pick<T>(rng: () => number, items: T[]): T {
  if (items.length === 0) {
    throw new Error('Cannot pick from empty array');
  }
  return items[Math.floor(rng() * items.length)];
}

/**
 * Pick random item with weights
 * @param rng - Random number generator function
 * @param weightedItems - Array of [item, weight] tuples
 * @returns Randomly selected item based on weights
 */
export function pickWeighted<T>(rng: () => number, weightedItems: [T, number][]): T {
  if (weightedItems.length === 0) {
    throw new Error('Cannot pick from empty weighted array');
  }
  
  const totalWeight = weightedItems.reduce((sum, [, weight]) => sum + weight, 0);
  let random = rng() * totalWeight;
  
  for (const [item, weight] of weightedItems) {
    random -= weight;
    if (random <= 0) {
      return item;
    }
  }
  
  // Fallback to last item
  return weightedItems[weightedItems.length - 1][0];
}

/**
 * Generate random integer in range [min, max)
 * @param rng - Random number generator function
 * @param min - Minimum value (inclusive)
 * @param max - Maximum value (exclusive)
 * @returns Random integer
 */
export function randomInt(rng: () => number, min: number, max: number): number {
  return Math.floor(rng() * (max - min)) + min;
}

/**
 * Generate random float in range [min, max)
 * @param rng - Random number generator function
 * @param min - Minimum value (inclusive)
 * @param max - Maximum value (exclusive)
 * @returns Random float
 */
export function randomFloat(rng: () => number, min: number, max: number): number {
  return rng() * (max - min) + min;
}
